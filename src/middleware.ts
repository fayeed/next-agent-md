import { NextResponse } from 'next/server'
import type { NextRequest, NextFetchEvent } from 'next/server'
import type { MarkdownAgentsOptions, NextMiddleware } from './types'
import { wantsMarkdown } from './detect'
import { fetchPageHtml } from './fetch-html'
import { stripBoilerplate } from './strip-boilerplate'
import { htmlToMarkdown } from './convert'
import { estimateTokens } from './tokens'

const DEFAULT_SKIP_HEADER = 'x-markdown-skip'

function buildContentSignalHeader(
  option: MarkdownAgentsOptions['contentSignal']
): string | null {
  if (!option) return null
  const signals = typeof option === 'object' ? option : {}
  const aiTrain = (signals.aiTrain ?? true) ? 'yes' : 'no'
  const search = (signals.search ?? true) ? 'yes' : 'no'
  const aiInput = (signals.aiInput ?? true) ? 'yes' : 'no'
  return `ai-train=${aiTrain}, search=${search}, ai-input=${aiInput}`
}

/**
 * Attempts to fetch a pre-built markdown file from public/.well-known/markdown/.
 * Returns the markdown string if found, null otherwise.
 *
 * Pre-built files are generated by `npx next-agent-md build` (or automatically
 * by the withAgentMd() config plugin after next build). Serving them avoids the
 * self-fetch + HTML→markdown conversion overhead for static pages.
 */
async function fetchPrebuiltMarkdown(
  request: NextRequest
): Promise<string | null> {
  const { pathname } = new URL(request.url)
  const slug = pathname === '/' ? 'index' : pathname.replace(/^\//, '')
  const mdUrl = new URL(`/.well-known/markdown/${slug}.md`, request.url)

  try {
    const res = await fetch(mdUrl.toString(), { cache: 'force-cache' })
    if (!res.ok) return null
    const ct = res.headers.get('content-type') ?? ''
    // Next.js serves unknown extensions as application/octet-stream
    if (!ct.includes('text') && !ct.includes('octet-stream') && !ct.includes('markdown')) {
      return null
    }
    return res.text()
  } catch {
    return null
  }
}

/**
 * Higher-order function that wraps a Next.js middleware (or runs standalone)
 * to serve Markdown responses to AI agents.
 *
 * When a request includes `Accept: text/markdown` or `?markdown=1`, the middleware:
 * 1. Checks for a pre-built .md file in public/.well-known/markdown/ (fast path)
 * 2. Falls back to self-fetching the page HTML, stripping boilerplate, and converting
 * 3. Returns the Markdown with an `x-markdown-tokens` token estimate header
 *
 * @example
 * // middleware.ts - zero config
 * import { withMarkdownForAgents } from 'next-agent-md'
 * export default withMarkdownForAgents()
 *
 * @example
 * // middleware.ts - wrapping existing middleware
 * import { withMarkdownForAgents } from 'next-agent-md'
 * import { myAuthMiddleware } from './lib/auth'
 * export default withMarkdownForAgents(myAuthMiddleware, { varyHeader: true })
 */
export function withMarkdownForAgents(options?: MarkdownAgentsOptions): NextMiddleware
export function withMarkdownForAgents(middleware: NextMiddleware, options?: MarkdownAgentsOptions): NextMiddleware
export function withMarkdownForAgents(
  middlewareOrOptions?: NextMiddleware | MarkdownAgentsOptions,
  options: MarkdownAgentsOptions = {}
): NextMiddleware {
  let middleware: NextMiddleware | undefined
  if (typeof middlewareOrOptions === 'function') {
    middleware = middlewareOrOptions
  } else if (middlewareOrOptions !== undefined) {
    options = middlewareOrOptions
  }
  const {
    skipHeader = DEFAULT_SKIP_HEADER,
    varyHeader = true,
    contentSignal = false,
    stripSelectors = [],
  } = options

  return async (request: NextRequest, event: NextFetchEvent) => {
    // ── LOOP PREVENTION ──────────────────────────────────────────────────────
    // If this is our own internal self-fetch, pass straight through.
    if (request.headers.get(skipHeader) === '1') {
      return middleware ? middleware(request, event) : NextResponse.next()
    }

    // ── MARKDOWN DETECTION ───────────────────────────────────────────────────
    if (!wantsMarkdown(request)) {
      return middleware ? middleware(request, event) : NextResponse.next()
    }

    // ── FAST PATH: pre-built markdown file ───────────────────────────────────
    // Generated at build time by `npx next-agent-md build` for static pages.
    // No self-fetch or HTML conversion needed - just serve the file directly.
    const prebuilt = await fetchPrebuiltMarkdown(request)
    if (prebuilt) {
      const responseHeaders = new Headers({
        'content-type': 'text/markdown; charset=utf-8',
        'x-markdown-tokens': String(estimateTokens(prebuilt)),
        'x-markdown-source': 'prebuilt',
      })
      if (varyHeader) responseHeaders.set('vary', 'accept')
      const contentSignalValue = buildContentSignalHeader(contentSignal)
      if (contentSignalValue) responseHeaders.set('content-signal', contentSignalValue)
      return new Response(prebuilt, { status: 200, headers: responseHeaders })
    }

    // ── SLOW PATH: self-fetch + convert ──────────────────────────────────────
    // Used for dynamic pages (or static pages not yet built with next-agent-md build).
    const html = await fetchPageHtml(request, skipHeader)

    if (!html) {
      // Graceful fallback: self-fetch failed (e.g. 404, auth-gated, non-HTML)
      return middleware ? middleware(request, event) : NextResponse.next()
    }

    // ── STRIP BOILERPLATE ────────────────────────────────────────────────────
    const cleanedHtml = stripBoilerplate(html, stripSelectors)

    // ── CONVERT TO MARKDOWN ──────────────────────────────────────────────────
    const markdown = htmlToMarkdown(cleanedHtml)

    // ── BUILD RESPONSE ───────────────────────────────────────────────────────
    const responseHeaders = new Headers({
      'content-type': 'text/markdown; charset=utf-8',
      'x-markdown-tokens': String(estimateTokens(markdown)),
    })

    if (varyHeader) {
      responseHeaders.set('vary', 'accept')
    }

    const contentSignalValue = buildContentSignalHeader(contentSignal)
    if (contentSignalValue) {
      responseHeaders.set('content-signal', contentSignalValue)
    }

    return new Response(markdown, {
      status: 200,
      headers: responseHeaders,
    })
  }
}
